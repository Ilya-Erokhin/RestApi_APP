from db import db


class StoreModel(db.Model):

# __tablename__ = 'stores':
# Это специальный атрибут класса StoreModel, который указывает на имя таблицы в базе данных, к которой будет привязан этот класс.
# В данном случае, каждый экземпляр StoreModel будет представлять одну запись в таблице с именем 'stores'.
    __tablename__ = 'stores'

# Определение атрибутов (столбцов) магазина:
# id: Это Primary Key для таблицы магазинов. В данном случае, это целое число (db.Integer).
# name: Это имя магазина, представленное строкой (максимальная длина 80 символов, db.String(80)).
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(80))

# items = db.relationship('ItemModel', lazy='dynamic'):
# Это связь между магазинами и товарами.
# Здесь мы определяем отношение "один-ко-многим" между магазинами и товарами, где один магазин может иметь несколько товаров.
# Это реализуется через атрибут items, который представляет список всех товаров, связанных с данным магазином.
# ПО ШАГАМ
# db.relationship: Это функция, предоставляемая SQLAlchemy, которая позволяет определить связь между различными моделями базы данных.
    # Она обеспечивает механизм для связи двух таблиц в базе данных.
# 'ItemModel': Это имя модели, с которой устанавливается связь. В данном случае, мы устанавливаем связь с моделью ItemModel.
# Параметр lazy в db.relationship позволяет вам определить, как и когда связанные объекты будут загружены из базы данных.

    items = db.relationship('ItemModel', back_populates='store', lazy='dynamic')

# ЕДИНСТВЕННЫЙ UNIT_TEST
# def __init__(self, name):
# Это конструктор класса StoreModel, который вызывается при создании нового объекта этого класса.
# Когда мы создаем новый магазин, мы передаем ему его имя, и конструктор инициализирует атрибут name объекта, чтобы сохранить переданное имя.
    def __init__(self, name):
        self.name = name

# def json(self):
# Этот метод возвращает словарь с данными о магазине и его товарам.
# Мы используем его для преобразования объекта StoreModel в формат JSON, чтобы включить информацию о всех его товарах.
# Метод проходит по всем товарам магазина (self.items.all()) и преобразует их в JSON-представления с помощью метода json() каждого товара.
    def json(self):
        return {'name': self.name, 'items': [item.json() for item in self.items.all()]}
# @classmethod
# Это специальный декоратор Python, который превращает метод класса в метод, который можно вызывать без создания экземпляра класса.
# В данном случае, мы используем @classmethod для создания метода, который будет искать магазин по его имени.

# find_by_name(cls, name):
# Это классовый метод (classmethod), который выполняет запрос к базе данных для поиска магазина по его имени.
# Он принимает имя в качестве аргумента и возвращает первый магазин с соответствующим именем, если такой магазин найден.
    @classmethod
    def find_by_name(cls, name):
        return cls.query.filter_by(name=name).first()


# save_to_db(self):
# Это метод, который сохраняет текущий объект ItemModel в базу данных.
# Он добавляет текущий элемент товара в текущую сессию базы данных (db.session) и затем сохраняет изменения в базе данных с помощью db.session.commit()
    def save_to_db(self):
        db.session.add(self)
        db.session.commit()

# delete_from_db(self):
# Это метод, который удаляет текущий объект ItemModel из базы данных.
# Он удаляет текущий элемент товара из текущей сессии базы данных (db.session) и сохраняет изменения с помощью db.session.commit().
    def delete_from_db(self):
        db.session.delete(self)
        db.session.commit()